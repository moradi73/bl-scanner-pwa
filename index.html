<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Escanea y organiza tus Bon de Livraison con OCR autom√°tico">
    <meta name="theme-color" content="#667eea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <title>BL Scanner Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://docs.opencv.org/4.5.2/opencv.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .header { background: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); position: sticky; top: 0; z-index: 100; }
        .header-content { max-width: 600px; margin: 0 auto; padding: 15px 20px; display: flex; align-items: center; justify-content: space-between; }
        .header-title h1 { color: #667eea; font-size: 22px; }
        .header-title p { color: #666; font-size: 12px; }
        .status-badge { font-size: 11px; font-weight: bold; padding: 5px 10px; border-radius: 20px; background: #d4edda; color: #155724; }
        .container { max-width: 600px; margin: 0 auto; padding: 15px; }
        .card { background: white; border-radius: 20px; padding: 20px; margin-bottom: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .card-title { font-size: 18px; font-weight: bold; color: #2d3748; margin-bottom: 15px; }
        .btn { width: 100%; padding: 16px; border: none; border-radius: 12px; font-size: 16px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 12px; color: white; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .btn-secondary { background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); }
        .btn-success { background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); flex: 2; }
        .btn-warning { background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%); flex: 1; }
        .btn-manual { background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%); }
        .btn-crop { background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%); }
        input[type="file"] { display: none; }
        .preview-container { position: relative; margin: 15px 0; }
        .preview-img { width: 100%; border-radius: 12px; }
        .canvas-container { position: relative; width: 100%; overflow: hidden; border-radius: 12px; }
        #previewCanvas, #croppedCanvas { max-width: 100%; height: auto; display: block; border-radius: 12px; }
        .loading { background: linear-gradient(135deg, #ebf4ff 0%, #e0e7ff 100%); border-radius: 12px; padding: 20px; margin: 15px 0; text-align: center; }
        .spinner { border: 4px solid #e2e8f0; border-top: 4px solid #667eea; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .progress-text { color: #667eea; font-weight: bold; font-size: 14px; }
        .error-box { background: linear-gradient(135deg, #fff5f5 0%, #fed7d7 100%); border: 2px solid #fc8181; border-radius: 12px; padding: 15px; margin: 15px 0; }
        .error-box h3 { color: #c53030; margin-bottom: 10px; font-size: 16px; }
        .error-box p { color: #742a2a; font-size: 14px; line-height: 1.5; }
        .error-box button { margin-top: 10px; }
        .data-box { background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%); border: 2px solid #48bb78; border-radius: 15px; padding: 20px; margin: 15px 0; }
        .data-box-header { text-align: center; margin-bottom: 15px; }
        .data-row { background: white; border-radius: 8px; padding: 12px; margin-bottom: 10px; display: flex; justify-content: space-between; }
        .data-label { font-weight: bold; color: #2d3748; }
        .data-value { color: #4a5568; text-align: right; max-width: 60%; word-break: break-word; }
        .pdf-name-box { background: white; border: 2px dashed #667eea; border-radius: 10px; padding: 15px; margin: 15px 0; }
        .pdf-name-box p { color: #667eea; font-family: monospace; font-size: 13px; word-break: break-all; }
        .button-group { display: flex; gap: 10px; margin-top: 15px; }
        .folder-badge { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 15px; border-radius: 10px; font-size: 14px; font-weight: bold; margin-bottom: 15px; display: inline-block; }
        .doc-item { background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%); border-left: 4px solid #667eea; border-radius: 12px; padding: 15px; margin-bottom: 12px; }
        .doc-name { font-weight: bold; font-size: 14px; color: #2d3748; margin-bottom: 8px; word-break: break-all; }
        .doc-date { font-size: 12px; color: #718096; margin-bottom: 12px; }
        .doc-actions { display: flex; gap: 8px; }
        .doc-actions button { flex: 1; padding: 12px; border: none; border-radius: 8px; font-size: 13px; font-weight: bold; cursor: pointer; }
        .doc-download { background: #667eea; color: white; }
        .doc-delete { background: #f56565; color: white; flex: 0 0 auto; padding: 12px 15px; }
        .empty-state { text-align: center; padding: 50px 20px; color: #a0aec0; }
        .info-box { background: linear-gradient(135deg, #ebf4ff 0%, #e0e7ff 100%); border: 2px solid #667eea; border-radius: 12px; padding: 15px; font-size: 13px; }
        .info-box ul { list-style: none; padding: 0; }
        .info-box li { padding: 8px 0; display: flex; gap: 8px; }
        .tip-box { background: linear-gradient(135deg, #fef5e7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 12px; padding: 12px; margin: 10px 0; font-size: 13px; color: #92400e; }
        .feature-badge { background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%); color: white; padding: 5px 12px; border-radius: 15px; font-size: 11px; font-weight: bold; display: inline-block; margin-left: 8px; }
        .crop-controls { display: flex; gap: 8px; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>üìÑ BL Scanner Pro <span class="feature-badge">‚úÇÔ∏è Auto-Crop</span></h1>
                <p>Bon de Livraison PWA</p>
            </div>
            <div id="statusBadge" class="status-badge">üü¢ Online</div>
        </div>
    </div>
    <div class="container">
        <div class="card">
            <div class="card-title">üì∏ Escanear Documento</div>
            <button class="btn btn-primary" onclick="document.getElementById('camera').click()">üì∑ Tomar Foto con C√°mara</button>
            <button class="btn btn-secondary" onclick="document.getElementById('file').click()">üñºÔ∏è Seleccionar de Galer√≠a</button>
            <input type="file" id="camera" accept="image/*" capture="environment" onchange="handleImage(this)">
            <input type="file" id="file" accept="image/*" onchange="handleImage(this)">
            <div class="tip-box">
                ‚úÇÔ∏è <strong>Auto-Recorte:</strong> La app detectar√° autom√°ticamente el documento y recortar√° los bordes.
            </div>
            <div id="preview"></div>
            <div id="cropControls" style="display:none;">
                <div class="crop-controls">
                    <button class="btn btn-crop" onclick="acceptCrop()">‚úÖ Aceptar Recorte</button>
                    <button class="btn btn-warning" onclick="retryCrop()">üîÑ Reintentar</button>
                </div>
            </div>
            <div id="loading" style="display:none;" class="loading">
                <div class="spinner"></div>
                <div class="progress-text" id="progressText">Procesando imagen...</div>
            </div>
            <div id="error"></div>
            <div id="result"></div>
        </div>
        <div class="card">
            <div class="card-title">üìÅ Documentos Guardados</div>
            <div class="folder-badge">üìÇ BL.MTR 2025</div>
            <div id="documentsCount" style="font-size: 14px; color: #666; margin-bottom: 15px;"></div>
            <div id="documents"></div>
        </div>
        <div class="card">
            <div class="card-title">‚ÑπÔ∏è Informaci√≥n PWA</div>
            <div class="info-box">
                <ul>
                    <li><span>‚úÖ</span> <span>Recorte autom√°tico de documentos</span></li>
                    <li><span>‚úÖ</span> <span>Correcci√≥n de perspectiva</span></li>
                    <li><span>‚úÖ</span> <span>Funciona sin conexi√≥n</span></li>
                    <li><span>‚úÖ</span> <span>OCR autom√°tico integrado</span></li>
                    <li><span>‚úÖ</span> <span>Genera PDFs descargables</span></li>
                </ul>
            </div>
        </div>
    </div>

    <canvas id="hiddenCanvas" style="display:none;"></canvas>
    <canvas id="previewCanvas" style="display:none;"></canvas>
    <canvas id="croppedCanvas" style="display:none;"></canvas>

    <script>
        let currentImageData = null;
        let currentImageFile = null;
        let extractedData = null;
        let documents = [];
        let ocrWorker = null;
        let croppedImageData = null;
        let opencvReady = false;

        // Esperar a que OpenCV est√© listo
        function onOpenCvReady() {
            opencvReady = true;
            console.log('OpenCV.js cargado correctamente');
        }

        // Timeout para OpenCV (si no carga en 10 segundos, continuar sin √©l)
        setTimeout(() => {
            if (!opencvReady) {
                console.warn('OpenCV no se carg√≥, continuando sin recorte autom√°tico');
                opencvReady = 'disabled';
            }
        }, 10000);

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(r => console.log('Service Worker registrado'))
                    .catch(e => console.log('Error SW:', e));
            });
        }

        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        function updateOnlineStatus() {
            const badge = document.getElementById('statusBadge');
            if (navigator.onLine) {
                badge.style.background = '#d4edda';
                badge.style.color = '#155724';
                badge.textContent = 'üü¢ Online';
            } else {
                badge.style.background = '#f8d7da';
                badge.style.color = '#721c24';
                badge.textContent = 'üî¥ Offline';
            }
        }

        function loadDocuments() {
            const saved = localStorage.getItem('bl_documents');
            if (saved) {
                try {
                    documents = JSON.parse(saved);
                } catch (e) {
                    console.error('Error cargando documentos:', e);
                    documents = [];
                }
                renderDocuments();
            } else {
                renderDocuments();
            }
        }

        function saveDocuments() {
            try {
                localStorage.setItem('bl_documents', JSON.stringify(documents));
            } catch (e) {
                console.error('Error guardando documentos:', e);
                alert('‚ö†Ô∏è Error al guardar. El almacenamiento puede estar lleno.');
            }
        }

        function handleImage(input) {
            const file = input.files[0];
            if (!file) return;

            currentImageFile = file;
            document.getElementById('error').innerHTML = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('cropControls').style.display = 'none';

            const reader = new FileReader();
            reader.onload = function(e) {
                currentImageData = e.target.result;
                detectAndCropDocument(e.target.result);
            };
            reader.onerror = function() {
                showError('Error al leer la imagen', 'No se pudo cargar la imagen. Intenta de nuevo.');
            };
            reader.readAsDataURL(file);
        }

        function detectAndCropDocument(imageData) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('progressText').textContent = 'Detectando documento...';

            const img = new Image();
            img.onload = function() {
                try {
                    if (opencvReady === true && typeof cv !== 'undefined') {
                        performDocumentDetection(img);
                    } else {
                        // Si OpenCV no est√° disponible, usar la imagen original
                        console.log('Usando imagen sin recorte autom√°tico');
                        croppedImageData = imageData;
                        document.getElementById('preview').innerHTML = 
                            '<div class="canvas-container"><img src="' + imageData + '" class="preview-img"></div>';
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('cropControls').style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error en detecci√≥n:', error);
                    croppedImageData = imageData;
                    document.getElementById('preview').innerHTML = 
                        '<div class="canvas-container"><img src="' + imageData + '" class="preview-img"></div>';
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('cropControls').style.display = 'block';
                }
            };
            img.src = imageData;
        }

        function performDocumentDetection(img) {
            try {
                // Crear canvas oculto
                const canvas = document.getElementById('hiddenCanvas');
                const ctx = canvas.getContext('2d');
                
                // Redimensionar si es muy grande
                let width = img.width;
                let height = img.height;
                const maxSize = 1500;
                
                if (width > maxSize || height > maxSize) {
                    const ratio = Math.min(maxSize / width, maxSize / height);
                    width = width * ratio;
                    height = height * ratio;
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);

                // Convertir a formato OpenCV
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                let gray = new cv.Mat();
                let blur = new cv.Mat();
                let edges = new cv.Mat();

                // Convertir a escala de grises
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // Aplicar blur para reducir ruido
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                
                // Detectar bordes
                cv.Canny(blur, edges, 75, 200);

                // Encontrar contornos
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

                // Encontrar el contorno m√°s grande (probablemente el documento)
                let maxArea = 0;
                let maxContourIndex = -1;
                
                for (let i = 0; i < contours.size(); i++) {
                    let contour = contours.get(i);
                    let area = cv.contourArea(contour);
                    if (area > maxArea && area > (width * height * 0.1)) { // Al menos 10% del √°rea
                        maxArea = area;
                        maxContourIndex = i;
                    }
                }

                if (maxContourIndex >= 0) {
                    let contour = contours.get(maxContourIndex);
                    
                    // Aproximar el contorno a un pol√≠gono
                    let peri = cv.arcLength(contour, true);
                    let approx = new cv.Mat();
                    cv.approxPolyDP(contour, approx, 0.02 * peri, true);

                    // Si tenemos 4 puntos, es probablemente un documento
                    if (approx.rows === 4) {
                        // Aplicar transformaci√≥n de perspectiva
                        const croppedCanvas = applyPerspectiveTransform(src, approx, width, height);
                        croppedImageData = croppedCanvas.toDataURL('image/jpeg', 0.9);
                        
                        document.getElementById('preview').innerHTML = 
                            '<div class="canvas-container"><img src="' + croppedImageData + '" class="preview-img"></div>';
                        document.getElementById('progressText').textContent = '‚úÖ Documento detectado y recortado';
                    } else {
                        // No se detect√≥ un documento cuadril√°tero, usar imagen original
                        croppedImageData = currentImageData;
                        document.getElementById('preview').innerHTML = 
                            '<div class="canvas-container"><img src="' + currentImageData + '" class="preview-img"></div>';
                        document.getElementById('progressText').textContent = '‚ö†Ô∏è No se detect√≥ documento, usando imagen original';
                    }

                    approx.delete();
                } else {
                    // No se encontr√≥ contorno v√°lido
                    croppedImageData = currentImageData;
                    document.getElementById('preview').innerHTML = 
                        '<div class="canvas-container"><img src="' + currentImageData + '" class="preview-img"></div>';
                    document.getElementById('progressText').textContent = '‚ö†Ô∏è No se detect√≥ documento, usando imagen original';
                }

                // Limpiar memoria
                src.delete();
                dst.delete();
                gray.delete();
                blur.delete();
                edges.delete();
                contours.delete();
                hierarchy.delete();

                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('cropControls').style.display = 'block';
                }, 500);

            } catch (error) {
                console.error('Error en OpenCV:', error);
                croppedImageData = currentImageData;
                document.getElementById('preview').innerHTML = 
                    '<div class="canvas-container"><img src="' + currentImageData + '" class="preview-img"></div>';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('cropControls').style.display = 'block';
            }
        }

        function applyPerspectiveTransform(src, approx, width, height) {
            // Obtener las 4 esquinas del documento
            const points = [];
            for (let i = 0; i < 4; i++) {
                points.push({
                    x: approx.data32S[i * 2],
                    y: approx.data32S[i * 2 + 1]
                });
            }

            // Ordenar puntos: top-left, top-right, bottom-right, bottom-left
            points.sort((a, b) => a.y - b.y);
            const topPoints = points.slice(0, 2).sort((a, b) => a.x - b.x);
            const bottomPoints = points.slice(2, 4).sort((a, b) => a.x - b.x);
            const orderedPoints = [...topPoints, ...bottomPoints];

            // Calcular dimensiones del documento rectificado
            const widthA = Math.sqrt(Math.pow(orderedPoints[2].x - orderedPoints[3].x, 2) + 
                                    Math.pow(orderedPoints[2].y - orderedPoints[3].y, 2));
            const widthB = Math.sqrt(Math.pow(orderedPoints[1].x - orderedPoints[0].x, 2) + 
                                    Math.pow(orderedPoints[1].y - orderedPoints[0].y, 2));
            const maxWidth = Math.max(widthA, widthB);

            const heightA = Math.sqrt(Math.pow(orderedPoints[1].x - orderedPoints[2].x, 2) + 
                                     Math.pow(orderedPoints[1].y - orderedPoints[2].y, 2));
            const heightB = Math.sqrt(Math.pow(orderedPoints[0].x - orderedPoints[3].x, 2) + 
                                     Math.pow(orderedPoints[0].y - orderedPoints[3].y, 2));
            const maxHeight = Math.max(heightA, heightB);

            // Crear matriz de transformaci√≥n
            const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                orderedPoints[0].x, orderedPoints[0].y,
                orderedPoints[1].x, orderedPoints[1].y,
                orderedPoints[2].x, orderedPoints[2].y,
                orderedPoints[3].x, orderedPoints[3].y
            ]);

            const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0,
                maxWidth, 0,
                maxWidth, maxHeight,
                0, maxHeight
            ]);

            const M = cv.getPerspectiveTransform(srcPoints, dstPoints);
            const warped = new cv.Mat();
            cv.warpPerspective(src, warped, M, new cv.Size(maxWidth, maxHeight));

            // Convertir a canvas
            const outputCanvas = document.getElementById('croppedCanvas');
            outputCanvas.width = maxWidth;
            outputCanvas.height = maxHeight;
            cv.imshow(outputCanvas, warped);

            // Limpiar
            srcPoints.delete();
            dstPoints.delete();
            M.delete();
            warped.delete();

            return outputCanvas;
        }

        function acceptCrop() {
            if (croppedImageData) {
                processImage(croppedImageData);
            }
        }

        function retryCrop() {
            if (currentImageFile) {
                const fakeInput = { files: [currentImageFile] };
                handleImage(fakeInput);
            }
        }

        async function processImage(imageData) {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('result').innerHTML = '';
            document.getElementById('error').innerHTML = '';
            document.getElementById('cropControls').style.display = 'none';
            
            try {
                document.getElementById('progressText').textContent = 'Inicializando OCR...';
                
                if (!navigator.onLine) {
                    throw new Error('No hay conexi√≥n a internet. El OCR necesita internet la primera vez.');
                }

                ocrWorker = await Tesseract.createWorker('fra', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            const percent = Math.round(m.progress * 100);
                            document.getElementById('progressText').textContent = 
                                'Extrayendo texto... ' + percent + '%';
                        } else if (m.status === 'loading tesseract core') {
                            document.getElementById('progressText').textContent = 
                                'Descargando OCR...';
                        } else if (m.status === 'initializing tesseract') {
                            document.getElementById('progressText').textContent = 
                                'Preparando OCR...';
                        } else if (m.status === 'loading language traineddata') {
                            document.getElementById('progressText').textContent = 
                                'Descargando idioma franc√©s...';
                        }
                    }
                });

                const { data: { text } } = await ocrWorker.recognize(imageData);
                
                await ocrWorker.terminate();
                ocrWorker = null;

                if (!text || text.trim().length === 0) {
                    throw new Error('No se pudo extraer texto. Intenta con mejor luz o enfoque.');
                }

                extractedData = extractBLData(text);
                document.getElementById('loading').style.display = 'none';
                displayExtractedData();
                
            } catch (error) {
                console.error('Error procesando imagen:', error);
                document.getElementById('loading').style.display = 'none';
                
                if (ocrWorker) {
                    try {
                        await ocrWorker.terminate();
                    } catch (e) {}
                    ocrWorker = null;
                }
                
                showError(
                    'Error al procesar imagen',
                    error.message || 'Error desconocido. Intenta de nuevo o usa entrada manual.',
                    true
                );
            }
        }

        function showError(title, message, showManualButton = false) {
            let html = '<div class="error-box">' +
                '<h3>‚ùå ' + title + '</h3>' +
                '<p>' + message + '</p>';
            
            if (showManualButton) {
                html += '<button class="btn btn-manual" onclick="showManualEntry()">' +
                    '‚úèÔ∏è Ingresar Datos Manualmente' +
                    '</button>';
            }
            
            html += '</div>';
            document.getElementById('error').innerHTML = html;
        }

        function showManualEntry() {
            const numero = prompt('N√∫mero BL:', '') || Math.floor(Math.random() * 9000000 + 1000000).toString();
            const fecha = prompt('Fecha (DD/MM/YYYY):', new Date().toLocaleDateString('es-ES')) || new Date().toLocaleDateString('es-ES');
            const cliente = prompt('Cliente:', 'CLIENTE') || 'CLIENTE';
            const nCommande = prompt('N¬∞ Commande:', numero) || numero;

            extractedData = { numero, fecha, cliente, nCommande };
            document.getElementById('error').innerHTML = '';
            displayExtractedData();
        }

        function extractBLData(text) {
            let numero = '', fecha = '', cliente = '', nCommande = '';
            
            try {
                const nombreMatch = text.match(/NOMBRE[:\s]+(\d+)/i) || 
                                   text.match(/N[¬∞\s]*COMMANDE[:\s]*([A-Z0-9\-]+)/i) ||
                                   text.match(/(\d{7})/);
                if (nombreMatch) numero = nombreMatch[1];
                
                const fechaMatch = text.match(/DATE[:\s]+(\d{2}[\/\-]\d{2}[\/\-]\d{4})/i) ||
                                  text.match(/(\d{2}[\/\-]\d{2}[\/\-]\d{4})/);
                if (fechaMatch) fecha = fechaMatch[1].replace(/-/g, '/');
                
                const clienteMatch = text.match(/GROUPEMENT[^\n]*/i) ||
                                    text.match(/SGTM[^\n]*/i) ||
                                    text.match(/DEPOT[^\n]*/i);
                if (clienteMatch) {
                    cliente = clienteMatch[0].trim().replace(/\s+/g, ' ').substring(0, 50);
                }
                
                const commandeMatch = text.match(/N[¬∞\s]*COMMANDE[:\s]*([A-Z0-9\-]+)/i) ||
                                     text.match(/COMMANDE[:\s]*([A-Z0-9\-]+)/i);
                if (commandeMatch) nCommande = commandeMatch[1];

            } catch (e) {
                console.error('Error extrayendo datos:', e);
            }

            if (!numero) numero = Math.floor(Math.random() * 9000000 + 1000000).toString();
            if (!fecha) fecha = new Date().toLocaleDateString('es-ES');
            if (!cliente) cliente = 'CLIENTE EXTRAIDO';
            if (!nCommande) nCommande = numero;

            return { numero, fecha, cliente, nCommande };
        }

        function displayExtractedData() {
            const pdfName = generatePDFName(extractedData);
            
            document.getElementById('result').innerHTML = 
                '<div class="data-box">' +
                '<div class="data-box-header"><span style="font-size: 30px;">‚úÖ</span><h3>Datos Extra√≠dos</h3></div>' +
                '<div class="data-row"><span class="data-label">N√∫mero BL:</span><span class="data-value">' + extractedData.numero + '</span></div>' +
                '<div class="data-row"><span class="data-label">Fecha:</span><span class="data-value">' + extractedData.fecha + '</span></div>' +
                '<div class="data-row"><span class="data-label">Cliente:</span><span class="data-value">' + extractedData.cliente + '</span></div>' +
                '<div class="data-row"><span class="data-label">N¬∞ Commande:</span><span class="data-value">' + extractedData.nCommande + '</span></div>' +
                '<div class="pdf-name-box"><label style="font-size:12px;font-weight:bold;color:#666;margin-bottom:8px;display:block;">üìÑ Nombre del PDF:</label><p>' + pdfName + '</p></div>' +
                '<div class="button-group">' +
                '<button class="btn btn-warning" onclick="editData()">‚úèÔ∏è Editar</button>' +
                '<button class="btn btn-success" onclick="saveDocument()">üíæ Guardar</button>' +
                '</div></div>';
        }

        function editData() {
            const newNumero = prompt('N√∫mero BL:', extractedData.numero);
            if (!newNumero) return;
            const newFecha = prompt('Fecha (DD/MM/YYYY):', extractedData.fecha);
            if (!newFecha) return;
            const newCliente = prompt('Cliente:', extractedData.cliente);
            if (!newCliente) return;
            const newCommande = prompt('N¬∞ Commande:', extractedData.nCommande);

            extractedData.numero = newNumero;
            extractedData.fecha = newFecha;
            extractedData.cliente = newCliente;
            if (newCommande) extractedData.nCommande = newCommande;
            
            displayExtractedData();
        }

        function generatePDFName(data) {
            const fechaFormatted = data.fecha.replace(/\//g, '-');
            const clienteTruncated = data.cliente.substring(0, 30).trim();
            return 'BL.' + data.numero + ' ' + fechaFormatted + ' ' + clienteTruncated + '.pdf';
        }

        function saveDocument() {
            if (!extractedData || !croppedImageData) {
                alert('‚ö†Ô∏è No hay datos para guardar');
                return;
            }

            try {
                const doc = {
                    id: Date.now(),
                    fileName: generatePDFName(extractedData),
                    data: extractedData,
                    image: croppedImageData,
                    timestamp: new Date().toISOString()
                };

                documents.unshift(doc);
                saveDocuments();
                renderDocuments();
                
                document.getElementById('preview').innerHTML = '';
                document.getElementById('result').innerHTML = '';
                document.getElementById('error').innerHTML = '';
                document.getElementById('cropControls').style.display = 'none';
                currentImageData = null;
                croppedImageData = null;
                extractedData = null;
                
                alert('‚úÖ Documento guardado exitosamente!\n\nüìÅ BL.MTR 2025/\n' + doc.fileName);
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } catch (e) {
                console.error('Error guardando documento:', e);
                alert('‚ùå Error al guardar el documento: ' + e.message);
            }
        }

        function renderDocuments() {
            const container = document.getElementById('documents');
            const countEl = document.getElementById('documentsCount');
            
            countEl.textContent = 'Total: ' + documents.length + ' documento' + (documents.length !== 1 ? 's' : '');
            
            if (documents.length === 0) {
                container.innerHTML = 
                    '<div class="empty-state">' +
                    '<div style="font-size:60px;opacity:0.3;margin-bottom:15px;">üìÑ</div>' +
                    '<p style="font-size:16px;font-weight:bold;margin-bottom:5px;">No hay documentos</p>' +
                    '<p style="font-size:14px;">Escanea tu primer BL para comenzar</p>' +
                    '</div>';
                return;
            }

            container.innerHTML = documents.map(doc => 
                '<div class="doc-item">' +
                '<div class="doc-name">üìÑ ' + doc.fileName + '</div>' +
                '<div class="doc-date">' + new Date(doc.timestamp).toLocaleString('es-ES') + '</div>' +
                '<div class="doc-actions">' +
                '<button class="doc-download" onclick="downloadPDF(' + doc.id + ')">‚¨áÔ∏è Descargar PDF</button>' +
                '<button class="doc-delete" onclick="deleteDoc(' + doc.id + ')">üóëÔ∏è</button>' +
                '</div></div>'
            ).join('');
        }

        async function downloadPDF(id) {
            const doc = documents.find(d => d.id === id);
            if (!doc) return;

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                
                pdf.setFontSize(16);
                pdf.setTextColor(102, 126, 234);
                pdf.text('Bon de Livraison', 105, 15, { align: 'center' });
                
                pdf.addImage(doc.image, 'JPEG', 10, 25, 190, 120);
                
                pdf.setFontSize(12);
                pdf.setTextColor(0, 0, 0);
                pdf.text('Numero BL: ' + doc.data.numero, 15, 155);
                pdf.text('Fecha: ' + doc.data.fecha, 15, 165);
                pdf.text('Cliente: ' + doc.data.cliente, 15, 175);
                pdf.text('N¬∞ Commande: ' + doc.data.nCommande, 15, 185);
                
                pdf.setFontSize(9);
                pdf.setTextColor(128, 128, 128);
                pdf.text('Generado por BL Scanner Pro', 105, 290, { align: 'center' });
                
                pdf.save(doc.fileName);
                
                alert('‚úÖ PDF descargado correctamente!\n\n' + doc.fileName);
            } catch (error) {
                console.error('Error generando PDF:', error);
                alert('‚ùå Error al generar PDF:\n' + error.message);
            }
        }

        function deleteDoc(id) {
            if (!confirm('¬øSeguro que deseas eliminar este documento?')) return;
            
            try {
                documents = documents.filter(d => d.id !== id);
                saveDocuments();
                renderDocuments();
            } catch (e) {
                console.error('Error eliminando documento:', e);
                alert('‚ùå Error al eliminar: ' + e.message);
            }
        }

        loadDocuments();
        updateOnlineStatus();

        window.addEventListener('beforeunload', () => {
            if (ocrWorker) {
                ocrWorker.terminate().catch(() => {});
            }
        });
    </script>
</body>
</html>